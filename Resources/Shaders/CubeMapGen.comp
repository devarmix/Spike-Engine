#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba32f) writeonly uniform imageCube outputCubemap;
layout(set = 0, binding = 1) uniform sampler2D equirectMap;

vec3 sampleDirection(uint face, vec2 uv) {

    uv = uv * 2.0 - 1.0; // [0,1] â†’ [-1,1]
    vec3 dir;
    if (face == 0) dir = normalize(vec3( 1.0, -uv.y, -uv.x)); // +X
    if (face == 1) dir = normalize(vec3(-1.0, -uv.y, uv.x));  // -X
    if (face == 2) dir = normalize(vec3( uv.x, 1.0, uv.y));   // +Y
    if (face == 3) dir = normalize(vec3( uv.x, -1.0, -uv.y)); // -Y
    if (face == 4) dir = normalize(vec3( uv.x, -uv.y, 1.0));  // +Z
    if (face == 5) dir = normalize(vec3(-uv.x, -uv.y, -1.0)); // -Z
    return dir;
}

vec2 dirToEquirectUV(vec3 dir) {

    float phi = atan(dir.z, dir.x);
    float theta = acos(clamp(dir.y, -1.0, 1.0));
    return vec2(phi / (2.0 * 3.1415926535) + 0.5, theta / 3.1415926535);
}

void main() {
    
    uvec3 gid = gl_GlobalInvocationID;
    uint face = gl_WorkGroupID.z;

    ivec2 size = imageSize(outputCubemap).xy;
    if (gid.x >= uint(size.x) || gid.y >= uint(size.y)) return;

    vec2 uv = vec2(gid.xy) / vec2(size);
    vec3 dir = sampleDirection(face, uv);
    vec2 eqUV = dirToEquirectUV(dir);
    vec3 color = texture(equirectMap, eqUV).rgb;

    imageStore(outputCubemap, ivec3(gid.xy, int(face)), vec4(color, 1.0));
}
