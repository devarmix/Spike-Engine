#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D NoiseTexture;
layout(set = 0, binding = 1) uniform sampler2D DepthMap;
layout(set = 0, binding = 2) uniform sampler2D NormalMap;

layout(set = 0, binding = 3, r32f) uniform writeonly image2D OutTexture;

layout(push_constant) uniform Constants {

    vec2 TexSize;

	float Radius;
	float Bias;

	uint SceneDataOffset;
    uint NumSamples;
    float Intensity;

	float pad0;
} SSAOConstants;

struct SceneDrawData {

	mat4 View;
	mat4 Proj;
	mat4 ViewProj;
	mat4 InverseProj;
	mat4 InverseView;

	vec4 CameraPos;

	float AmbientIntensity;
	float NearProj;
	float FarProj;

	float pad0;
};

#define MAX_SCENE_DRAWS_PER_FRAME 8

layout(std140, set = 1, binding = 0) uniform DeclSceneDataBuffer {

	SceneDrawData SceneData[MAX_SCENE_DRAWS_PER_FRAME];
} SceneDataBuffer;

const uint KERNEL_SIZE = 32;
const vec3 KernelData[KERNEL_SIZE] = {

		vec3(-0.668154f, -0.084296f, 0.219458f),
		vec3(-0.092521f,  0.141327f, 0.505343f),
		vec3(-0.041960f,  0.700333f, 0.365754f),
		vec3( 0.722389f, -0.015338f, 0.084357f),
		vec3(-0.815016f,  0.253065f, 0.465702f),
		vec3( 0.018993f, -0.397084f, 0.136878f),
		vec3( 0.617953f, -0.234334f, 0.513754f),
		vec3(-0.281008f, -0.697906f, 0.240010f),
		vec3( 0.303332f, -0.443484f, 0.588136f),
		vec3(-0.477513f,  0.559972f, 0.310942f),
		vec3( 0.307240f,  0.076276f, 0.324207f),
		vec3(-0.404343f, -0.615461f, 0.098425f),
		vec3( 0.152483f, -0.326314f, 0.399277f),
		vec3( 0.435708f,  0.630501f, 0.169620f),
		vec3( 0.878907f,  0.179609f, 0.266964f),
		vec3(-0.049752f, -0.232228f, 0.264012f),
		vec3( 0.537254f, -0.047783f, 0.693834f),
		vec3( 0.001000f,  0.177300f, 0.096643f),
		vec3( 0.626400f,  0.524401f, 0.492467f),
		vec3(-0.708714f, -0.223893f, 0.182458f),
		vec3(-0.106760f,  0.020965f, 0.451976f),
		vec3(-0.285181f, -0.388014f, 0.241756f),
		vec3( 0.241154f, -0.174978f, 0.574671f),
		vec3(-0.405747f,  0.080275f, 0.055816f),
		vec3( 0.079375f,  0.289697f, 0.348373f),
		vec3( 0.298047f, -0.309351f, 0.114787f),
		vec3(-0.616434f, -0.117369f, 0.475924f),
		vec3(-0.035249f,  0.134591f, 0.840251f),
		vec3( 0.175849f,  0.971033f, 0.211778f),
		vec3( 0.024805f,  0.348056f, 0.240006f),
		vec3(-0.267123f,  0.204885f, 0.688595f),
		vec3(-0.077639f, -0.753205f, 0.070938f)
};

vec3 GetViewPosFromDepth(vec2 texCoord) {

    const vec4 ndc = vec4(texCoord * 2.f - 1.f, texture(DepthMap, texCoord).r, 1.f);

    mat4 invProj = SceneDataBuffer.SceneData[SSAOConstants.SceneDataOffset].InverseProj;
    vec4 posVS = invProj * ndc;

    return posVS.xyz / posVS.w; 
}

float GenSSAO(vec2 texCoord) {

    const uvec2 noiseScale = uvec2(SSAOConstants.TexSize / 4.0f);
    const vec3 randomVec = normalize(texture(NoiseTexture, texCoord * noiseScale).xyz);

    const vec3 viewPos = GetViewPosFromDepth(texCoord);

    mat4 view = SceneDataBuffer.SceneData[SSAOConstants.SceneDataOffset].View;
    mat4 proj = SceneDataBuffer.SceneData[SSAOConstants.SceneDataOffset].Proj;
    vec3 viewNormal = mat3(view) * texture(NormalMap, texCoord).xyz;

    const vec3 T = normalize(randomVec - viewNormal * dot(randomVec, viewNormal));
    const vec3 B = cross(viewNormal, T);
    const mat3 TBN = mat3(T, B, viewNormal); 

    float occlusion = 0.0f;
    for (int i = 0; i < SSAOConstants.NumSamples; i++) {

        vec3 samplePos = TBN * KernelData[i].xyz;
        samplePos = viewPos + samplePos * SSAOConstants.Radius;

        const vec3 sampleDir = normalize(samplePos - viewPos);
        vec4 offsetUV = vec4(samplePos, 1.0f);
        offsetUV = proj * offsetUV;
        offsetUV.xy = (offsetUV.xy / offsetUV.w) * .5f + .5f;

        if (offsetUV.x < 0.0f || offsetUV.x > 1.0f || offsetUV.y < 0.0f || offsetUV.y > 1.0f)
            continue;
        
        const float sampledGeometryDepth = GetViewPosFromDepth(offsetUV.xy).z;
        const float rangeCheck = smoothstep(0.0f, 1.f, SSAOConstants.Radius / abs(viewPos.z - sampledGeometryDepth));
        occlusion += step(samplePos.z + SSAOConstants.Bias, sampledGeometryDepth) * rangeCheck;
    }
    
    occlusion = 1.0 - occlusion / float(SSAOConstants.NumSamples);
    return pow(abs(occlusion), SSAOConstants.Intensity);
}

void main() {

    ivec2 invocID = ivec2(gl_GlobalInvocationID);

    vec2 imgSize = SSAOConstants.TexSize;
    vec2 texCoord = vec2(float(invocID.x) / imgSize.x, float(invocID.y) / imgSize.y);
    texCoord += (1.0f / imgSize) * 0.5f;

    float ssao = GenSSAO(texCoord);
    imageStore(OutTexture, invocID, vec4(ssao));
}